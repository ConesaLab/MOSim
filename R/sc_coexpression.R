#' check_patterns
#' 
#' Function to check if the TRUE FALSE patterns have at least two rows that are
#' opposite, we need this to be able to generate repressor regulators
#'
#' @param patterns_ret tibble of TRUE FALSE values
#' @export
#' @return list of indices where the rows are opposite
#'
#' @examples
#' patterns <- tibble::tibble(one = c(TRUE, FALSE, TRUE, FALSE), 
#'               two = c(TRUE, TRUE, TRUE, TRUE), 
#'               three = c(FALSE, TRUE, FALSE, TRUE), 
#'               four = c(FALSE, TRUE, TRUE, TRUE))
#' opposite_indices <- check_patterns(patterns)
#' 
check_patterns <- function(patterns_ret){
  ## Check that there are at least two opposing patterns
  # Get the number of rows in the tibble
  num_rows <- nrow(patterns_ret)
  
  # Initialize a list to store the indices of opposite rows
  opposite_indices <- list()
  
  # Generate all possible combinations of row indices
  row_combinations <- expand.grid(1:num_rows, 1:num_rows)
  
  # Iterate over each combination of row indices
  for (i in 1:nrow(row_combinations)) {
    # Get the row indices for comparison
    row_index1 <- row_combinations[i, 1]
    row_index2 <- row_combinations[i, 2]
    
    # Check if the rows are opposite
    if (all(patterns_ret[row_index1, ] != patterns_ret[row_index2, ])) {
      opposite_indices <- c(opposite_indices, list(c(row_index1, row_index2)))
    }
  }
  return(opposite_indices)
}


#' make_cluster_patterns
#' 
#' Function to make the tibble with cluster combinations for the gene expression
#' patterns along the cells
#'
#' @param numcells Number of different celltypes we are simulating
#' @param clusters OPTIONAL. Number of co-expression patterns the user wants
#'      to simulate
#'
#' @return A tibble with number of columns equal to number of celltypes, rows
#'  according to the number of TRUE/FALSE combinations corresponding to the
#'  gene expression patterns along the cells
#' @export
#' @examples
#' patterns <- make_cluster_patterns(numcells = 4, clusters = 8)
#' cell_types <- list('CD4_TEM' = c(1:60), 'cDC' = c(299:310), 
#'     'Memory_B' = c(497:520), 'Treg' = c(868:900))
#' patterns <- make_cluster_patterns(numcells = length(cell_types), 
#'     clusters = 8)
#' 
make_cluster_patterns <- function(numcells = 4, clusters = 8){
  
  patterns <- tibble::tibble()
  col_names <- paste0("Var", 1:numcells)
  
  for (i in 0:(2^numcells - 1)) {
    boolArr <- vector(mode = "logical", length = numcells)
    
    # Increasing or decreasing depending on which direction
    # you want your array to represent the binary number
    for (j in (numcells - 1):0) {
      boolArr[j + 1] <- as.logical(bitwAnd(i, 2^j))
    }
    
    patterns <- rbind(patterns, boolArr)
  }
  
  colnames(patterns) <- col_names
  # Subset to number of clusters the user wants
  patterns_ret <- dplyr::slice_sample(patterns, n = clusters)
  
  opposite_indices <- check_patterns(patterns_ret)
  
  # Check if opposite rows were found, if not, sample again, we need at least
  # two rows that are opposite
  if (length(opposite_indices) < 1){
    for (e in 1:10){
      # Try again
      patterns_ret <- dplyr::slice_sample(patterns, n = clusters)
      opposite_indices <- check_patterns(patterns_ret)
      if (length(opposite_indices) >= 1){
        break
      }
    }
  }
  return(list("patterns" = patterns_ret, "opposite_indices" = opposite_indices))
}

#' simulate coexpression
#' 
#' Adapted from ACORDE (https://github.com/ConesaLab/acorde) to adapt to our
#' data input type. Simulates coexpression of genes along celltypes
#'
#' @param sim_matrix Matrix with rows as features and columns as cells
#' @param feature_no Total number of features to be distributed between the 
#'    coexpression clusters
#' @param cellTypes list where the i-th element of the list contains the column 
#'    indices for i-th experimental conditions. List must be a named list.
#' @param patterns Tibble with TRUE FALSE depicting the cluster patterns to
#'    simulate. Generated by the user or by \code{make_cluster_patterns}.
#' @param cluster_size OPTIONAL. It may be inputted by the user. By default, 
#'    its the number of features divided by the number of patterns to generate.
#'
#' @return the simulated coexpression
#' @export

simulate_coexpression <- function(sim_matrix,
                                  feature_no, cellTypes,
                                  patterns,
                                  cluster_size = NULL){
  
  ## If no cluster size specified, make it by default
  if (is.null(cluster_size)){
    cluster_size <- feature_no/dim(patterns)[1]
  }
  
  # Define notin to filter later on
  `%notin%` <- Negate(`%in%`)
  
  # extract counts 
  normcounts <- as.data.frame(sim_matrix)
  # get cell ids in each cell type
  colData <- tibble::tibble(Cell = colnames(normcounts),
                            Group = rep(names(cellTypes), times = lengths(cellTypes)))
  
  group.list <- colData$Cell %>% split(colData$Group)
  # extract cell type (group) expr matrices
  normcounts.list <- purrr::map(group.list,
                                ~(normcounts[, as.character(.)] %>%
                                    tibble::rownames_to_column("feature")))
  
  # rank features by mean expression in each cell type
  normcounts.list <- purrr::map(normcounts.list,
                                ~dplyr::mutate(., mean = rowMeans(.[,-1])) %>%
                                  dplyr::arrange(dplyr::desc(mean))
                                %>% dplyr::select(-mean))
  
  # select top and bottom feature IDs for each cell type
  
  # top
  top_features.list <- purrr::map(normcounts.list,
                                  ~dplyr::select(., feature) %>%
                                    dplyr::rename(top = "feature") %>%
                                    dplyr::slice(., 1:feature_no) %>%
                                    tibble::as_tibble())
  
  # modify bottom feature no. to create range correctly
  feature_no.c <- nrow(normcounts) - (feature_no - 1)
  # bottom
  bottom_features.list <- purrr::map(normcounts.list,
                                     ~dplyr::select(., feature) %>%
                                       dplyr::rename(bottom = "feature") %>%
                                       dplyr::slice(., feature_no.c:nrow(normcounts)) %>%
                                       tibble::as_tibble())
  
  # create a two-col tibble with top/bottom features per group
  features.list <- purrr::map2(top_features.list, bottom_features.list,
                               dplyr::bind_cols)
  
  
  ## USE SUPPLIED PATTENRS TO SHUFFLE THE CELL TYPE MATRICES ##
  
  # match column names for patterns
  colnames(patterns) <- names(normcounts.list)
  
  # shuffle matrix for each cell type following cluster patterns
  # note that internal function shuffle_group_matrix() is used to perform
  # each individual shuffling operation
  
  # calculate no. of clusters based on size and number of features
  partitions <- feature_no / cluster_size
  partitions <- trunc(partitions)
  
  expr.list <- purrr::pmap(list(normcounts.list, features.list, patterns),
                           ~MOSim::shuffle_group_matrix(sim_data = ..1,
                                                        feature_ids = ..2,
                                                        group_pattern = ..3,
                                                        ngroups = partitions))
  
  feature_names <- expr.list[[1]]$feature
  
  # join cell type matrices into a single expression matrix
  expr.list <- purrr::map(expr.list, dplyr::select, -feature)
  coexpr.df <- dplyr::bind_cols(expr.list) %>% tibble::as_tibble()
  
  # merge all dataframes in the list by feature column, fillna the genes not 
  coexpr.df <- coexpr.df %>%
    #dplyr::mutate(feature = paste0("Feature", seq(1, nrow(coexpr.df)))) %>%
    dplyr::mutate(feature = feature_names) %>%
    dplyr::relocate(feature)
  
  # generate feature ID vectors for co-expression clusters
  clusters <- split(coexpr.df$feature,
                    cut(seq(1, nrow(coexpr.df)),
                        breaks = nrow(patterns), labels = FALSE))
  
  # New, not in acorde's simulate coexpression
  # Get the genes that we havent used into the table
  # Format the simulated dataframe as tibble with feature column and get the 
  # missing rows into the coexpression DF
  normcounts <- dplyr::mutate_all(normcounts, function(x) as.double(x))
  normcounts$feature <- rownames(normcounts)
  normcounts <- tibble::as_tibble(normcounts)
  # Sort the columnames according to the simulated dataframe
  normcounts <- normcounts[, colnames(coexpr.df)]
  
  # remove from the original simulated matrix the features co-regulated
  normcounts <- normcounts %>%
    dplyr::filter(feature %notin% coexpr.df$feature)
  
  ## Bring back other features not corregulated
  coexpr.df <- dplyr::bind_rows(coexpr.df, normcounts) %>% replace(is.na(.), 0)
  
  # build a list with results
  coexpr_sim <- list(sim_matrix = coexpr.df,
                     sim_clusters = clusters)
  return(coexpr_sim)
  
}


#' shuffle_group_matrix, Reorder cell type-specific expression matrix during 
#' co-expression simulation. Copied from ACORDE (https://github.com/ConesaLab/acorde)
#' to facilitate stability and running within our scripts
#' 
#' @description This function is used internally by \code{acorde} to perform
#' the shuffling of simulated features for an individual cell type, as part of
#' the co-expression simulation process. The function is called recursively by
#' \code{\link[MOSim:simulate_coexpression]{simulate_coexpression()}} to
#' perform the simulation on a full scRNA-seq matrix.
#'
#' @param sim_data A count matrix with features as rows and cells as columns.
#' Feature IDs must be included in an additional column named \code{feature}.
#' @param feature_ids A two-column \code{tibble} containing \code{top} and \code{bottom}
#' columns, each including the feature IDs of features to be used as highly or
#' lowly expressed when shuffling by the indicated expression pattern.
#' @param group_pattern A logical vector, containing \code{TRUE} to indicate that
#' high expression in that cell type is desired and \code{FALSE} if the opposite.
#' The vector must be ordered as the cell types in \code{sim_data}.
#' @param ngroups An integer indicating the number of groups that top and bottom
#' features should be divided into. It is computed by dividing the number
#' of features selected as highly/lowly expressed by the size of the clusters
#' that are to be generated.
#' @export
#' @return An expression matrix, with the same characteristics as \code{sim_data},
#' and a number of features defined as the total amount of top/bottom features
#' selected divided by the number of clusters for which co-expression patterns
#' where supplied.

shuffle_group_matrix <- function(sim_data, feature_ids, group_pattern, ngroups){
  
  # select top and bottom features in group
  top <- dplyr::select(feature_ids, top) %>% unlist
  bottom <- dplyr::select(feature_ids, bottom) %>% unlist
  
  # random partitioning of features
  # top
  top.shuffle <- sample(length(top))
  top <- top[top.shuffle]
  top.list <- split(top, cut(seq(1, length(top)), breaks = ngroups, labels = FALSE))
  # bottom
  bottom.shuffle <- sample(length(bottom))
  bottom <- bottom[bottom.shuffle]
  bottom.list <- split(bottom, cut(seq(1, length(bottom)), breaks = ngroups, labels = FALSE))
  
  # bind features following pattern
  features_bound <- vector(mode = "list", length = length(group_pattern))
  # Remove harmless warning
  suppressWarnings(features_bound[group_pattern] <- top.list)
  suppressWarnings(features_bound[!group_pattern] <- bottom.list)
  features_bound <- unlist(features_bound)
  
  # build expression matrix for group
  sim_data.mod <- sim_data %>%
    dplyr::filter(feature %in% features_bound) %>%
    tibble::column_to_rownames("feature")
  sim_data.mod <- sim_data.mod[features_bound,] %>% tibble::rownames_to_column("feature")
  
  return(sim_data.mod)
}


#' make_association_dataframe
#' 
#' This function generates a dataframe containing the information of the 
#' relationship between ATAC and RNA, based on the cluster groups, and then
#' tells the order the genes and peaks should be in the simulated dataframe
#' of the group
#'
#' @param group Group from which we are generating the association dataframe
#' @param genereggroup list of elements to generate the association dataframe
#'      such as clusters of each omic, indices of opposite clusters, which
#'      genes are activated, repressed, behavior of the features etc.
#' @return a dataframe with all the information the user needs about each gene
#'      and the order of gene and peak names to rename them in the simulated
#'      datasets of the group
#' @export
#'
make_association_dataframe <- function(group, genereggroup){
  # Start from the association list, now we have two columns Peak_ID and Gene_ID
  
  columns <- c("Gene_ID", "Peak_ID", "RegulatorEffect", "Gene_cluster", "Peak_cluster", 
               "Gene_DE", "Peak_DE")
  
  df1 <- data.frame(matrix(nrow = length(genereggroup[[paste0("GeneActivated_G", 
                                    group)]]$Gene_ID), ncol = length(columns)))
  colnames(df1) <- columns
  
  df1["Gene_ID"] <- genereggroup[[paste0("GeneActivated_G", group)]]$Gene_ID
  df1["Peak_ID"] <- genereggroup[[paste0("GeneActivated_G", group)]]$Peak_ID
  df1["RegulatorEffect"] <- rep("Activator", length(df1[[1]]))
  Gene_cluster <- sample(1:length(genereggroup$`Clusters_scRNA-seq`), 
                         length(df1[[1]]), replace = TRUE)
  Peak_cluster <- Gene_cluster
  df1["Gene_DE"] <- rep("Up", length(df1[[1]]))
  df1["Peak_DE"] <- rep("Up", length(df1[[1]]))
  
  
  df2 <- data.frame(matrix(nrow = length(genereggroup[[paste0("GeneRepressed_G", 
                                    group)]]$Gene_ID), ncol = length(columns)))
  colnames(df2) <- columns
  df2["Gene_ID"] <- genereggroup[[paste0("GeneRepressed_G", group)]]$Gene_ID
  df2["Peak_ID"] <- genereggroup[[paste0("GeneRepressed_G", group)]]$Peak_ID
  df2["RegulatorEffect"] <- rep("Repressor", length(df2[[1]]))
  Gene_cluster2 <- sample(unique(unlist(genereggroup$opposite_indices)), 
                          length(df2[[1]]), replace = TRUE)
  u <- as.data.frame(t(as.data.frame(genereggroup$opposite_indices)))
  Peak_cluster <- c(Peak_cluster, u[[2]][match(Gene_cluster2, u[[1]])])
  Gene_cluster <- c(Gene_cluster, Gene_cluster2)
  df2["Gene_DE"] <- rep("Down", length(df2[[1]]))
  df2["Peak_DE"] <- rep("Up", length(df2[[1]]))
  
  df3 <- data.frame(matrix(nrow = length(c(genereggroup[[paste0("GeneExtraUp_G", 
                    group)]], rep(NA, length(genereggroup[[paste0("FeatExtraUp_G", 
                    group)]])))), ncol = length(columns)))
  colnames(df3) <- columns
  df3["Gene_ID"] <- c(genereggroup[[paste0("GeneExtraUp_G", group)]], 
                      rep(NA, length(genereggroup[[paste0("FeatExtraUp_G", group)]])))
  df3["Peak_ID"] <- c(rep(NA, length(genereggroup[[paste0("GeneExtraUp_G", group)]])), 
                      genereggroup[[paste0("FeatExtraUp_G", group)]])
  df3["RegulatorEffect"] <- rep("NE", length(df3[[1]]))
  Gene_clusterNA <- c(rep(1, length(genereggroup[[paste0("GeneExtraUp_G", group)]])), 
                      rep(NA, length(genereggroup[[paste0("FeatExtraUp_G", group)]])))
  Peak_clusterNA <- c(rep(NA, length(genereggroup[[paste0("GeneExtraUp_G", group)]])), 
                      rep(1, length(genereggroup[[paste0("FeatExtraUp_G", group)]])))
  df3["Gene_DE"] <- c(rep("Up", length(genereggroup[[paste0("GeneExtraUp_G", group)]])), 
                      rep(NA, length(genereggroup[[paste0("FeatExtraUp_G", group)]])))
  df3["Peak_DE"] <- c(rep(NA, length(genereggroup[[paste0("GeneExtraUp_G", group)]])), 
                      rep("Up", length(genereggroup[[paste0("FeatExtraUp_G", group)]])))
  
  df4 <- data.frame(matrix(nrow = length(c(genereggroup[[paste0("GeneExtraDown_G", group)]], 
                                           rep(NA, length(genereggroup[[paste0("FeatExtraDown_G", group)]])))), ncol = length(columns)))
  colnames(df4) <- columns
  df4["Gene_ID"] <- c(genereggroup[[paste0("GeneExtraDown_G", group)]], 
                      rep(NA, length(genereggroup[[paste0("FeatExtraDown_G", group)]])))
  df4["Peak_ID"] <- c(rep(NA, length(genereggroup[[paste0("GeneExtraDown_G", group)]])), 
                      genereggroup[[paste0("FeatExtraDown_G", group)]])
  df4["RegulatorEffect"] <- rep("NE", length(df4[[1]]))
  Gene_clusterNA <- c(Gene_clusterNA, 
                      rep(1, length(genereggroup[[paste0("GeneExtraDown_G", group)]])), 
                      rep(NA, length(genereggroup[[paste0("FeatExtraDown_G", group)]])))
  Peak_clusterNA <- c(Peak_clusterNA, 
                      rep(NA, length(genereggroup[[paste0("GeneExtraDown_G", group)]])), 
                      rep(1, length(genereggroup[[paste0("FeatExtraDown_G", group)]])))
  df4["Gene_DE"] <- c(rep("Down", length(genereggroup[[paste0("GeneExtraDown_G", group)]])), 
                      rep(NA, length(genereggroup[[paste0("FeatExtraDown_G", group)]])))
  df4["Peak_DE"] <- c(rep(NA, length(genereggroup[[paste0("GeneExtraDown_G", group)]])), 
                      rep("Down", length(genereggroup[[paste0("FeatExtraDown_G", group)]])))
  
  df5 <- data.frame(matrix(nrow = length(c(genereggroup[[paste0("GeneRemaining_G", group)]], 
                                    rep(NA, length(genereggroup[[paste0("FeatRemaining_G", group)]])))), 
                           ncol = length(columns)))
  colnames(df5) <- columns
  df5["Gene_ID"] <- c(genereggroup[[paste0("GeneRemaining_G", group)]], 
                      rep(NA, length(genereggroup[[paste0("FeatRemaining_G", group)]])))
  df5["Peak_ID"] <- c(rep(NA, length(genereggroup[[paste0("GeneRemaining_G", group)]])), 
                      genereggroup[[paste0("FeatRemaining_G", group)]])
  df5["RegulatorEffect"] <- rep("NE", length(df5[[1]]))
  
  Gene_clusterNA <- c(Gene_clusterNA, 
                      rep(1, length(genereggroup[[paste0("GeneRemaining_G", group)]])), 
                      rep(NA, length(genereggroup[[paste0("FeatRemaining_G", group)]])))
  Peak_clusterNA <- c(Peak_clusterNA, 
                      rep(NA, length(genereggroup[[paste0("GeneRemaining_G", group)]])), 
                      rep(1, length(genereggroup[[paste0("FeatRemaining_G", group)]])))
  
  df5["Gene_DE"] <- c(rep("NE", length(genereggroup[[paste0("GeneRemaining_G", group)]])), 
                      rep(NA, length(genereggroup[[paste0("FeatRemaining_G", group)]])))
  df5["Peak_DE"] <- c(rep(NA, length(genereggroup[[paste0("GeneRemaining_G", group)]])), 
                      rep("NE", length(genereggroup[[paste0("FeatRemaining_G", group)]])))
  
  # Concat dataframes of DE genes and features
  df <- rbind(df1, df2, df3, df4, df5)
  ## Now I have to figure out how to repartir the rest of genes and features in the cluster groups and whichever ones dont fit, put cluster 0
  clRNA <- as.data.frame(length(genereggroup$`Clusters_scRNA-seq`[[1]]) - table(Gene_cluster[Gene_cluster != 0]))
  
  clATAC <- as.data.frame(length(genereggroup$`Clusters_scATAC-seq`[[1]]) - table(Peak_cluster[Peak_cluster != 0]))
  lRNA <- list()
  lATAC <- list()
  # Generate a vector of numbers of clusters with the missing values to be able to fill it
  for (e in 1:length(clRNA[[1]])){
    ## Some times this line gives me a size error, but I can-t reproduce it
    lRNA[[e]] <- rep(clRNA[e, ][[1]], as.numeric(clRNA[e, ][[2]]))
  }
  
  clus <- setdiff(c(1:length(genereggroup$`Clusters_scRNA-seq`)), unique(Gene_cluster))
  lRNA[["clus"]] <- rep(clus, each = length(genereggroup$`Clusters_scRNA-seq`[[1]]))
  lRNA <- lapply(lRNA, as.character)
  lRNA <- lapply(lRNA, as.integer)
  lRNA <- as.numeric(as.vector(unlist(lRNA)))

  for (e in 1:length(clATAC[[1]])){
    lATAC[[e]] <- rep(clATAC[e, ][[1]], as.numeric(clATAC[e, ][[2]]))
  }
  clus <- setdiff(c(1:length(genereggroup$`Clusters_scATAC-seq`)), unique(Peak_cluster))
  lATAC[["clus"]] <- rep(clus, each = length(genereggroup$`Clusters_scATAC-seq`[[1]]))
  lATAC <- lapply(lATAC, as.character)
  lATAC <- lapply(lATAC, as.integer)
  lATAC <- as.numeric(as.vector(unlist(lATAC)))
  
  zeros <- sum(!is.na(Gene_clusterNA)) - length(lRNA)
  lRNA <- c(lRNA, rep(0, zeros))

  zeros <- sum(!is.na(Peak_clusterNA)) - length(lATAC)
  lATAC <- c(lATAC, rep(0, abs(zeros)))
  
  ## Shuffle the values so they are not sorted by number of the cluster
  lRNA <- sample(lRNA)
  lATAC <- sample(lATAC)
  
  positions <- which(Gene_clusterNA == 1)
  Gene_clusterNA[positions] <- lRNA[1:length(positions)]
  
  positions <- which(Peak_clusterNA == 1)
  Peak_clusterNA[positions] <- lATAC[1:length(positions)]
  
  df["Gene_cluster"] <- c(Gene_cluster, Gene_clusterNA)
  df["Peak_cluster"] <- c(Peak_cluster, Peak_clusterNA)
  
  ## Finally we sort the dataframe according to the clusters
  Geneorder <- df[df$Gene_cluster %in% c(1:length(genereggroup$`Clusters_scRNA-seq`)),]
  dfGeneNames <- rbind(Geneorder[order(Geneorder$Gene_cluster),], 
                       df[!df$Gene_cluster %in% c(1:length(genereggroup$`Clusters_scRNA-seq`)),])
  rownames(dfGeneNames) <- 1:nrow(dfGeneNames)
  dfGeneNames <- dfGeneNames$Gene_ID
  
  Peakorder <- df[df$Peak_cluster %in% c(1:length(genereggroup$`Clusters_scATAC-seq`)),]
  dfPeakNames <- rbind(Peakorder[order(Peakorder$Peak_cluster),], 
                       df[!df$Peak_cluster %in% c(1:length(genereggroup$`Clusters_scATAC-seq`)),])
  rownames(dfPeakNames) <- 1:nrow(dfPeakNames)
  dfPeakNames <- dfPeakNames$Peak_ID
  
  return(list("associationMatrix" = df, "dfPeakNames" = dfPeakNames, "dfGeneNames" = dfGeneNames))
  
}

#' order_FC_forMatrix
#' 
#' Function to sort the FC values according to the genes that must be up or 
#' downregulated
#'
#' @param A Vector of c("Up", "Down", "NE) from the Gene or Peak_DE extracted
#'          from the association matrix
#' @param B Calculated vector of Up FC values
#' @param C Calculated vector of Down FC values
#' @param D Calculated vector of NE FC values
#'
#' @export
#'
#' @examples
#' DE <- c("Up", "Up", "Up", "Down", "Down", "NE", "NE", "NE", "NE", NA, NA, NA)
#' Up_FCvec <- c(1, 1, 1)
#' Down_FCvec <- c(2, 2)
#' notDE_FCvec <- c(2, 2, 2, 2)
#' FC_vec <- order_FC_forMatrix(DE, Up_FCvec, Down_FCvec, notDE_FCvec)
#' 
order_FC_forMatrix <- function(A, B, C, D){
  # Initialize an empty vector to store the result
  # Remove NAs
  A<-A[!is.na(A)]
  
  result <- vector("character", length(A))
  
  # Create counters for each vector
  counter_B <- 1
  counter_C <- 1
  counter_D <- 1
  
  # Loop through vector A
  for (i in seq_along(A)) {
    if (is.na(A[i])) {
      # If NA is encountered, skip and continue to the next element
      next
    } else if (A[i] == "Up") {
      # Assign value from vector B to the result
      result[i] <- B[counter_B]
      # Increment the counter for vector B
      counter_B <- counter_B + 1
      # If we reached the end of vector B, reset the counter
      if (counter_B > length(B)) {
        counter_B <- 1
      }
    } else if (A[i] == "Down") {
      # Assign value from vector C to the result
      result[i] <- C[counter_C]
      # Increment the counter for vector C
      counter_C <- counter_C + 1
      # If we reached the end of vector C, reset the counter
      if (counter_C > length(C)) {
        counter_C <- 1
      }
    } else if (A[i] == "NE") {
      # Assign value from vector D to the result
      result[i] <- D[counter_D]
      # Increment the counter for vector D
      counter_D <- counter_D + 1
      # If we reached the end of vector D, reset the counter
      if (counter_D > length(D)) {
        counter_D <- 1
      }
    }
  }
  
  # Print the resulting vector
  return(result)
}
