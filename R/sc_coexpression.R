#' make_cluster_patterns
#' 
#' Function to make the tibble with cluster combinations for the gene expression
#' patterns along the cells
#'
#' @param numcells Number of different celltypes we are simulating
#' @param clusters OPTIONAL. Number of co-expression patterns the user wants
#'      to simulate
#'
#' @return A tibble with number of columns equal to number of celltypes, rows
#'  according to the number of TRUE/FALSE combinations corresponding to the
#'  gene expression patterns along the cells
#' @export
#' @examples
#' patterns <- make_cluster_patterns(numcells = 4, clusters = 8)
#' patterns <- make_cluster_patterns(numcells = length(cell_types), 
#'     clusters = 8)
#' 
make_cluster_patterns <- function(numcells = 4, clusters = 8){
  
  patterns <- tibble()
  col_names <- paste0("Var", 1:numcells)
  
  for (i in 0:(2^numcells - 1)) {
    boolArr <- vector(mode = "logical", length = numcells)
    
    # Increasing or decreasing depending on which direction
    # you want your array to represent the binary number
    for (j in (numcells - 1):0) {
      boolArr[j + 1] <- as.logical(bitwAnd(i, 2^j))
    }
    
    patterns <- rbind(patterns, boolArr)
  }
  
  colnames(patterns) <- col_names
  # Subset to number of clusters the user wants
  patterns <- dplyr::slice_sample(patterns, n = clusters)
  return(patterns)
}

#' simulate coexpression
#' 
#' Adapted from ACORDE (https://github.com/ConesaLab/acorde) to adapt to our
#' data input type. Simulates coexpression of genes along celltypes
#'
#' @param sim_matrix Matrix with rows as features and columns as cells
#' @param numberCells Same parameter as used for \code{scMOSim}. Vector of 
#'    numbers. The numbers correspond to the number of cells the user wants to 
#'    simulate per each cell type. The length of the vector must be the same as 
#'    length of \code{cellTypes}.
#' @param feature_no Total number of features to be distributed between the 
#'    coexpression clusters
#' @param cellTypes list where the i-th element of the list contains the column 
#'    indices for i-th experimental conditions. List must be a named list.
#' @param patterns Tibble with TRUE FALSE depicting the cluster patterns to
#'    simulate. Generated by the user or by \code{make_cluster_patterns}.
#' @param cluster_size OPTIONAL. It may be inputted by the user. By default, 
#'    its the number of features divided by the number of patterns to generate.
#'
#' @return the simulated coexpression
#' @export
#' @examples
#' omic_list <- sc_omicData(c("scRNA-seq", "scATAC-seq"))
#' cell_types <- list('CD4_TEM' = c(1:60), 'cDC' = c(299:310), 
#'     'Memory_B' = c(497:520), 'Treg' = c(868:900))
#' sim <-scMOSim(omic_list, cell_types, numberCells = c(100, 100, 100, 100))
#' patterns <- make_cluster_patterns(length(cell_types), clusters = 8)
#' simulate_coexpression(sim$Group_1$Rep_1$sim_scRNA-seq@assays$RNA@counts, 
#' feature_no = 3200, numberCells = c(100, 100, 100, 100)
#' patterns)
#' 
simulate_coexpression <- function(sim_matrix, numberCells,
                                  feature_no, cellTypes,
                                  patterns,
                                  cluster_size = NULL){
  
  ## If no cluster size specified, make it by default
  if (is.null(cluster_size)){
    cluster_size <- feature_no/dim(patterns)[1]
  }
  
  # Define notin to filter later on
  `%notin%` <- Negate(`%in%`)
  
  # extract counts 
  normcounts <- as.data.frame(sim_matrix)
  # get cell ids in each cell type
  colData <- tibble::tibble(Cell = colnames(normcounts),
                            Group = rep(names(cellTypes), times = numberCells))
  
  group.list <- colData$Cell %>% split(colData$Group)
  # extract cell type (group) expr matrices
  normcounts.list <- purrr::map(group.list,
                                ~(normcounts[, as.character(.)] %>%
                                    tibble::rownames_to_column("feature")))
  
  # rank features by mean expression in each cell type
  normcounts.list <- purrr::map(normcounts.list,
                                ~dplyr::mutate(., mean = rowMeans(.[,-1])) %>%
                                  dplyr::arrange(dplyr::desc(mean))
                                %>% dplyr::select(-mean))
  
  # select top and bottom feature IDs for each cell type
  
  # top
  top_features.list <- purrr::map(normcounts.list,
                                  ~dplyr::select(., feature) %>%
                                    dplyr::rename(top = "feature") %>%
                                    dplyr::slice(., 1:feature_no) %>%
                                    tibble::as_tibble())
  
  # modify bottom feature no. to create range correctly
  feature_no.c <- nrow(normcounts) - (feature_no - 1)
  # bottom
  bottom_features.list <- purrr::map(normcounts.list,
                                     ~dplyr::select(., feature) %>%
                                       dplyr::rename(bottom = "feature") %>%
                                       dplyr::slice(., feature_no.c:nrow(normcounts)) %>%
                                       tibble::as_tibble())
  
  # create a two-col tibble with top/bottom features per group
  features.list <- purrr::map2(top_features.list, bottom_features.list,
                               dplyr::bind_cols)
  
  
  ## USE SUPPLIED PATTENRS TO SHUFFLE THE CELL TYPE MATRICES ##
  
  # match column names for patterns
  colnames(patterns) <- names(normcounts.list)
  
  # shuffle matrix for each cell type following cluster patterns
  # note that internal function shuffle_group_matrix() is used to perform
  # each individual shuffling operation
  
  # calculate no. of clusters based on size and number of features
  partitions <- feature_no / cluster_size
  partitions <- trunc(partitions)
  
  expr.list <- purrr::pmap(list(normcounts.list, features.list, patterns),
                           ~MOSim::shuffle_group_matrix(sim_data = ..1,
                                                        feature_ids = ..2,
                                                        group_pattern = ..3,
                                                        ngroups = partitions))
  
  feature_names <- expr.list[[1]]$feature
  
  # join cell type matrices into a single expression matrix
  expr.list <- purrr::map(expr.list, dplyr::select, -feature)
  coexpr.df <- dplyr::bind_cols(expr.list) %>% tibble::as_tibble()
  
  # merge all dataframes in the list by feature column, fillna the genes not 
  coexpr.df <- coexpr.df %>%
    #dplyr::mutate(feature = paste0("Feature", seq(1, nrow(coexpr.df)))) %>%
    dplyr::mutate(feature = feature_names) %>%
    dplyr::relocate(feature)
  
  # generate feature ID vectors for co-expression clusters
  clusters <- split(coexpr.df$feature,
                    cut(seq(1, nrow(coexpr.df)),
                        breaks = nrow(patterns), labels = FALSE))
  
  # New, not in acorde's simulate coexpression
  # Get the genes that we havent used into the table
  # Format the simulated dataframe as tibble with feature column and get the 
  # missing rows into the coexpression DF
  normcounts <- dplyr::mutate_all(normcounts, function(x) as.double(x))
  normcounts$feature <- rownames(normcounts)
  normcounts <- tibble::as_tibble(normcounts)
  # Sort the columnames according to the simulated dataframe
  normcounts <- normcounts[, colnames(coexpr.df)]
  
  # remove from the original simulated matrix the features co-regulated
  normcounts <- normcounts %>%
    dplyr::filter(feature %notin% coexpr.df$feature)
  
  ## Bring back other features not corregulated
  coexpr.df <- dplyr::bind_rows(coexpr.df, normcounts) %>% replace(is.na(.), 0)
  
  # build a list with results
  coexpr_sim <- list(sim_matrix = coexpr.df,
                     sim_clusters = clusters)
  return(coexpr_sim)
  
}


#' shuffle_group_matrix, Reorder cell type-specific expression matrix during 
#' co-expression simulation. Copied from ACORDE (https://github.com/ConesaLab/acorde)
#' to facilitate stability and running within our scripts
#' 
#' @description This function is used internally by \code{acorde} to perform
#' the shuffling of simulated features for an individual cell type, as part of
#' the co-expression simulation process. The function is called recursively by
#' \code{\link[MOSim:simulate_coexpression]{simulate_coexpression()}} to
#' perform the simulation on a full scRNA-seq matrix.
#'
#' @param sim_data A count matrix with features as rows and cells as columns.
#' Feature IDs must be included in an additional column named \code{feature}.
#' @param feature_ids A two-column \code{tibble} containing \code{top} and \code{bottom}
#' columns, each including the feature IDs of features to be used as highly or
#' lowly expressed when shuffling by the indicated expression pattern.
#' @param group_pattern A logical vector, containing \code{TRUE} to indicate that
#' high expression in that cell type is desired and \code{FALSE} if the opposite.
#' The vector must be ordered as the cell types in \code{sim_data}.
#' @param ngroups An integer indicating the number of groups that top and bottom
#' features should be divided into. It is computed by dividing the number
#' of features selected as highly/lowly expressed by the size of the clusters
#' that are to be generated.
#' @export
#' @return An expression matrix, with the same characteristics as \code{sim_data},
#' and a number of features defined as the total amount of top/bottom features
#' selected divided by the number of clusters for which co-expression patterns
#' where supplied.

shuffle_group_matrix <- function(sim_data, feature_ids, group_pattern, ngroups){
  
  # select top and bottom features in group
  top <- dplyr::select(feature_ids, top) %>% unlist
  bottom <- dplyr::select(feature_ids, bottom) %>% unlist
  
  # random partitioning of features
  # top
  top.shuffle <- sample(length(top))
  top <- top[top.shuffle]
  top.list <- split(top, cut(seq(1, length(top)), breaks = ngroups, labels = FALSE))
  # bottom
  bottom.shuffle <- sample(length(bottom))
  bottom <- bottom[bottom.shuffle]
  bottom.list <- split(bottom, cut(seq(1, length(bottom)), breaks = ngroups, labels = FALSE))
  
  # bind features following pattern
  features_bound <- vector(mode = "list", length = length(group_pattern))
  # Remove harmless warning
  suppressWarnings(features_bound[group_pattern] <- top.list)
  suppressWarnings(features_bound[!group_pattern] <- bottom.list)
  features_bound <- unlist(features_bound)
  
  # build expression matrix for group
  sim_data.mod <- sim_data %>%
    dplyr::filter(feature %in% features_bound) %>%
    tibble::column_to_rownames("feature")
  sim_data.mod <- sim_data.mod[features_bound,] %>% tibble::rownames_to_column("feature")
  
  return(sim_data.mod)
}

