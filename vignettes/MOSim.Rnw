%\VignetteEngine{knitr::knitr}

\documentclass{article}
\usepackage[utf8]{inputenc}
<<style-knitr, eval=TRUE, echo=FALSE, results="asis">>=
BiocStyle::latex2()
options(tidy.opts=list(blank=FALSE, width.cutoff=60))
@

\bioctitle[MOSim]{MOSim}
\author{Sonia Tarazona, Carlos Mart\'inez}

\begin{document}

\maketitle

\begin{abstract}
This vignette describes the ...
\end{abstract}

\packageVersion{\Sexpr{BiocStyle::pkg_ver("MOSim")}}

\tableofcontents

\newpage

\section{Introduction}

The algorithm used by \Biocpkg{MOSim} package could be considered as a series of different omic data simulations that are managed and coordinated by a central independent system, so that the final values of each one adheres to the logic of the generated simulation settings.

Inside the available omics is RNA-seq, providing gene expression measurements. The regulation of those genes can be affected by many different systems, with data given by other omics like DNase-seq, ChIP-seq, etc. So in order to provide simulated datasets similar to the ones that could be obtained from a complex live biological system, those interactions must be modeled.

In order to the simulation to work, an initial counts dataset must be provided for each simulated omic, as explained in [Referencia paper]. Also, for regulators, an association table to the linked genes must also be given. For convenience, \Biocpkg{MOSim} includes default datasets from the project STATegra for all omics, so the package can still be used in absence of custom data.

Due do the potentially great amount of information generated, multiple helper functions are available both for passing the necessary input data and to retrieve the generated one.

\section{Input data and simulation}

Inside input data 2 different types can be distinguished: the one related to the omics to simulate and the experimental design to use in the overall process.

As stated, for the simulation algorithm to work, it needs to start from an initial dataset for each omic and, in case of regulators, include the association list with genes as well. In the event that none of that data is provided, the package includes default datasets that will be used.

The experimental design options are flexible, but there are some unavoidable limitations. For instance, to model differentially expressed genes, at least 2 groups must be present when no time series is considered, more information about this can be readed on the algorithm vignette (o paper?).

Aside from the experimental design, which could be considered as global simulation options shared by the whole process, each omic can have its own configuration parameters.

With that in mind, there are 3 main input helper functions to control it in an easier way.

\subsection{Running the simulation: \Rfunction{mosim}}

The \Rfunction{mosim} function is the one that takes the input and performs the simulation internally. It constitutes the entry point of those input options regarding the experimental design, as well as receiving the options list generated by other functions, so it makes sense to explain it first.

For illustration purposes, starting with the most basic usage example, it only requires the list of omics to simulate, leaving the other parameters with the default values which, among other things, will load the STATegra initial dataset.

<<load, echo=FALSE, eval=TRUE>>=
library(MOSim)
@

<<code, echo=TRUE, eval=FALSE>>=
omic_list <- c("RNA-seq")

rnaseq_simulation <- mosim(omics = omic_list)
@

The \Robject{rnaseq\textunderscore~simulation} value will be a \Rclass{Simulation} object that can be accessed in the way described later in this document.

Continuing with that basic example, the \Rfunction{mosim} function also accepts the parameters to control the experimental design. For instance, to simulate an scenario with 2 groups, 1 time point and 4 replicates, the code would be:

<<code2, echo=TRUE, eval=FALSE>>=
rnaseq_simulation <- mosim(omics = c("RNA-seq"),
                           times = 0,
                           numberGroups = 2,
                           numberReps = 4)
@

As previously told, if we try to use invalid combinations, the program would stop the execution:

<<code3, echo=TRUE, eval=TRUE, include=TRUE, error=TRUE>>=
rnaseq_simulation <- mosim(omics = c("RNA-seq"),
                           times = 0,
                           numberGroups = 1,
                           numberReps = 4)
@

To use more than one omic, it is enough to include it in the list. It should be noted that RNA-seq is mandatory, so if is not provided on the list it will be automatically included at the start of the simulation, so these two simulations would be equivalent:

<<code4, echo=TRUE, eval=FALSE>>=
multi_simulation <- mosim(omics = c("RNA-seq", "DNase-seq"),
                           times = 0,
                           numberGroups = 2,
                           numberReps = 4)

dnase_simulation <- mosim(omics = c("DNase-seq"),
                           times = 0,
                           numberGroups = 2,
                           numberReps = 4)
@

To configure each omic individually, 2 other utility functions can be used: \Rfunction{omicData} and \Rfunction{omicSim}.

\subsection{Providing custom data: \Rfunction{omicData}}

Even though the simulation process will use a default initial counts dataset if none is provided, it is preferred to use a custom one adjusted to the experiment particularities.

One way to do it is to use the function \Rfunction{omicData}, providing a data frame with only one column named "Counts" and the omic identifiers used as row names. For instance, starting with RNA-seq and just for the sake of example, consider a subset of the default data as the custom dataset:

<<code5, echo=TRUE, eval=FALSE,cache=TRUE, tidy=FALSE>>=
custom_rnaseq <- head(sampleData$SimRNAseq$data, 100)

# In this case, 'custom_rnaseq' is a data frame with
# the structure:
head(custom_rnaseq)
##                    Counts
## ENSMUSG00000000001   6572
## ENSMUSG00000000003      0
## ENSMUSG00000000028   4644
## ENSMUSG00000000031      8
## ENSMUSG00000000037      0
## ENSMUSG00000000049      0

rnaseq_customdata <- omicData("RNA-seq", data = custom_rnaseq)

rnaseq_simulation <- mosim(omics = list("RNA-seq" = rnaseq_customdata))
@

The result of \Robject{omicData} would be an initialized \Rclass{Simulator} object, that can be passed directly to the \Rfunction{mosim} function, by using the \Robject{omics} option passing a \Rclass{list} like showed.

This example, RNA-seq, constitutes an special case of omic because it do not require an association list; however for the rest of them, like DNase-seq, that list should be included along the custom dataset:

<<code6, echo=TRUE, eval=FALSE, tidy=FALSE>>=
# Select a subset of the available data as a custom dataset
custom_dnaseseq <- head(sampleData$SimDNaseseq$data, 100)

# Create the association list only of those genes
dnase_genes <- sampleData$SimDNaseseq$idToGene
dnase_genes <- dnase_genes[dnase_genes$ID %in%
                               rownames(custom_dnaseseq), ]

# In this case, 'custom_dnaseseq' is a data frame with
# the structure:
head(custom_dnaseseq)
##                       Counts
## 1_63176480_63177113      513
## 1_125435495_125436168   1058
## 1_128319376_128319506     37
## 1_139067124_139067654    235
## 1_152305595_152305752    105
## 1_172490322_172490824    290

# The association list 'dnase_genes' is another data frame
# with the structure:
head(dnase_genes)
##                      ID               Gene
## 29195 1_3670777_3670902 ENSMUSG00000051951
## 29196 1_3873195_3873351 ENSMUSG00000089420
## 29197 1_4332428_4332928 ENSMUSG00000025900
## 29198 1_4346315_4346445 ENSMUSG00000025900
## 29199 1_4416827_4416973 ENSMUSG00000025900
## 29200 1_4516660_4516798 ENSMUSG00000096126

dnaseseq_customdata <- omicData("DNase-seq",
                                data = custom_dnaseseq,
                                associationList = dnase_genes)

multi_simulation <- mosim(omics = list(
    "RNA-seq" = rnaseq_customdata,
    "DNase-seq" = dnaseseq_customdata)
    )
@

As seen, the association list should be a data frame with two columns named "ID" and "Gene", not in row names, so the same ID can be repeated any number of times and affect multiple genes.


\subsection{Tunning omic settings: \Rfunction{omicSim}}

Ths function \Rfunction{omicSim} allows to provide individual configuration parameters to each of the omics in a straightforward way.

Back to the first example using the default dataset, if we wanted to restrict the number of features, the code to use would be:

<<code7, echo=TRUE, eval=FALSE>>=
omic_list <- c("RNA-seq")

rnaseq_options <- omicSim("RNA-seq", totalFeatures = 2500)

rnaseq_simulation <- mosim(omics = omic_list,
                           omicsOptions = rnaseq_options)
@

To use this function with multiple omics, it is enough to concatenate the outputs:

<<code8, echo=TRUE, eval=FALSE>>=
omics_list <- c("RNA-seq", "DNase-seq")

omics_options <- c(omicSim("RNA-seq", totalFeatures = 2500),
                   omicSim("DNase-seq", totalFeatures = 1500))

multi_simulation <- mosim(omics = omics_list,
                          omicsOptions = omics_options)
@

This function is compatible with simulators already initialized using \Rfunction{omicData}:

<<code9, echo=TRUE, eval=FALSE>>=
rnaseq_customdata <- omicData("RNA-seq", data = custom_rnaseq)
rnaseq_options <- omicSim("RNA-seq", totalFeatures = 100)

rnaseq_simulation <- mosim(omics = list("RNA-seq" = rnaseq_customdata),
                           omicsOptions = rnaseq_options)
@

\section{Output data}

[Introducción a datos de salida, descripción de estructuras y significado de cada columna?]

Once the simulation process has finished, there are two main pieces of data that should be retrieved: for one part the simulated features for each omic, and for the other the settings used to generate them, for instance the genes marked as differentially expressed in RNA-seq.

Altough the simulation algorithm is thoroughly explained in [Insertar referencia al paper], the part required to understand the structure of the generated data is included in a summarized way in this vignette.

\subsection{Simulation settings}

The package generates different datasets which, ultimately, are correlated at some extent with the central piece: gene expression data, represented by RNA-seq omic.

This means that the configuration settings followed by all the simulation process start by defining how will be modeled the differences in gene expression among the different scenarios described by the experimental design provided.

Depending on that mentioned experimental design, the main options that have real impact in configuration settings are times and number of conditions. For instance, differentially expressed genes could be considered those that change its expression over time, or which expression levels differs between multiple groups.

Assuming the simplest scenario, in which no time series is considered and 2 conditions are compared, a gene would be differentially expressed when it is clearly expressed on one condition, but completely repressed on the other.

In a design with multiple time points, different expression patterns can be simulated:

\begin{description}
    \item[Continuous induction] lineal increase of the activity of the gene with time.
    \item[Continuous repression] lineal decrease of the activity of the gene with time.
    \item[Transitory induction] inactive gene at the initial time, with progressive increasing of the activity followed by a decrease.
    \item[Transitory repression] active gene at the initial time, with progressive decreasing of the activity followed by an increase.
    \item[Flat] the activity of the gene remains constant along time.
\end{description}

So in this last scenario with a time series, a gene would be differentially expressed when having anyother pattern different than flat. In that last case, for those genes that do not change its activity with time to be considered differentially expressed would require at least 2 groups with differences in the expression levels, like in the previously mentioned example.

Back to the simulation settings generation, being a RNA-seq oriented system, the first step is to classify the genes to simulate in 3 groups:

\begin{itemize}
    \item Differentially expressed genes (DEG).
    \item Non-differentially expressed genes (Non-DEG).
    \item Non-expressed genes.
\end{itemize}

Then, for each DEG a profile pattern is assigned with a user configurable probability, leaving the others as flat. In the abscence of a time series in the experimental design, only the flat profile is considered.

To this point, only the RNA-seq related simulation settings are defined, and the next step is to use them to generate the regulator omics settings.

In complex living organisms, like humans, the effect of a regulator can be different depending on many factors, for instance methylation is usually associated with repression when affects the gene promoter, but its presence on the gene body facilitates the transcription, thus producing an enhancing activity.

So summarizing there are two fundamental effects that a regulator can have on a gene: enhancing and repressing activity. After retrieving the full association list between the regulator IDs and genes, a random effect -the same for all conditions- is assigned to those linked to DEG, allowing the user to restrain the options to chose from, because some regulators only show one type of activity at all times.

Due to that random assigment and the fact that one regulator can affect more than one gene, it could happen that a same regulator tries to regulate genes with opposite gene classes. To avoid that, in the event that multiple gene classes are regulated by the same regulator, the majoritary class, or one at random in case of tie, is selected, nullifying the association with the other genes so no false links are returned (cambiar esto último).

To simulate the counts the same steps as the RNA-seq are applied with one consideration, when the experimental design includes a time series, the effect of the regulator on the gene and the expression pattern of the later are taken into account so they are coordinated. For instance, if the activity of a gene increases with time and the associated regulator has a repression effect, then the regulator values must follow an opposite trend, decreasing when the gene expression increases.


% Each of those patterns is assigned based on a user configurable probability, but by default it could occur that, for instance, in an experimental design with a time series and 2 groups, a DEG ends with a flat profile on the 2 conditions, so it would be incorrectly tagged as DEG when the simulated expression levels will be similar. To avoid this in this case, as in every other in which is necessary to force the differentially expressed status of a gene, the initial counts values are modified to reflect that.

\subsection{Accessing the data: \Rfunction{omicSettings} and \Rfunction{omicResults}}



To access the data matrices, \Biocpkg{MOSim} provides the function \Rfunction{omicResults}. Considering the object \Robject{multi\textunderscore~simulation} from the previous examples, it could be used as:

<<code10, echo=TRUE, eval=FALSE>>=
# multi_simulation is an object returned by mosim function.

# This will be a data frame with RNA-seq counts
rnaseq_simulated <- omicResults(multi_simulation, "RNA-seq")

# This wil be a list containing RNA-seq and DNase-seq counts
all_simulated <- omicResults(multi_simulation)
@

The other function, \Rfunction{omicSettings} returns a data frame will information specific to each omic (expression profiles, genes affected by a regulator...). Its use is pretty straighforward and similar to the previous one:

<<code10b, echo=TRUE, eval=FALSE>>=
# This will be a data frame with RNA-seq settings (DE flag, profiles)
rnaseq_settings <- omicSettings(multi_simulation, "RNA-seq")

# This wil be a list containing RNA-seq and DNase-seq settings
all_settings <- omicSettings(multi_simulation)
@

In case we also want to retrieve the association lists used, the parameter \Robject{association} must be set:

<<code10c, echo=TRUE, eval=FALSE, tidy=TRUE>>=
# This will be a list with 2 keys: settings and association
dnase_settings <- omicSettings(multi_simulation, "DNAse-seq",
                               association = TRUE)
@


\section{Advanced use cases}

Most of the usual needs should be covered by the showed examples, so unless more customized settings are required this section can be skipped.

\subsection{Custom noise function}

By default the noise function used is \Rfunction{rnorm}, with parameters \Rcode{sd=0.3}. In case we want to use a different function, the parameters to change would be \Robject{noiseFunction} pointing to the definition of the function itself, and \Robject{noiseParams} to pass new parameters. Note that the function must accept a numeric parameter called \Robject{n}, which indicates the lenght of the numeric vector it should return:

<<code11, echo=TRUE, eval=FALSE>>=
mynoise <- function(n, customparam) {
    # Let's just call rnorm
    noise.output <- rnorm(n, sd = customparam)

    return(noise.output)
}

rnaseq_simulation <- mosim(omics = c("RNA-seq"),
                           times = 0,
                           numberGroups = 2,
                           numberReps = 4,
                           noiseFunction = mynoise,
                           noiseParams = list("customparam" = 20)
                           )
@

In the process of making replicates witht the negative binomial distribution, a certain noise is applied using by default the first parameter of `noiseParams` to simplify things. However, this value can be personalized just by simply including a `NB` element in the `noiseParams` list. This parameter will be ignored in the call to `noiseFunction`:

<<code12, echo=TRUE, eval=FALSE>>=

# Custom NB noise value
rnaseq_simulation <- mosim(omics = c("RNA-seq"),
                           times = 0,
                           numberGroups = 2,
                           numberReps = 4,
                           noiseParams = list("NB" = 20)
                           )
@


\section{Setup}

This vignette was built on:

<<session, echo=FALSE, eval=TRUE>>=
devtools::session_info()
@

\section*{References}

\end{document}
